<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Responsive Reverse Kinematics Etch-A-Sketch</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles */
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            display: flex;
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #e5e7eb; /* gray-200 */
            overflow: hidden;
            padding: 1rem; /* Added padding to body for small screens */
        }
        #etch-a-sketch-frame {
            background-color: #dc2626; /* red-600 */
            border-radius: 20px;
            /* Responsive Padding */
            padding: 1rem; /* p-4 */
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2), inset 0 0 10px rgba(0,0,0,0.3);
            cursor: grab;
            position: relative;
            /* Responsive Width: Full width on small, max width on larger */
            width: 100%;
            max-width: 32rem; /* max-w-lg */
            border: 2px solid #b91c1c;
            transition: transform 0.1s ease-out;
        }
        @media (min-width: 640px) { /* sm breakpoint */
             #etch-a-sketch-frame {
                 padding: 1.5rem; /* sm:p-6 */
             }
        }

        #etch-a-sketch-frame.grabbing {
            cursor: grabbing;
            transition: none;
        }
        #drawingCanvas {
            touch-action: none;
            cursor: crosshair;
            border-radius: 8px;
            background-color: #d1d5db; /* gray-300 */
            border: 4px solid #9ca3af; /* gray-400 */
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
            display: block;
            position: relative;
            overflow: hidden;
             /* Make canvas display width responsive, maintain aspect ratio */
            width: 100%;
            aspect-ratio: 500 / 350; /* Maintain 10:7 ratio based on buffer size */
            height: auto; /* Height determined by width and aspect ratio */
        }
        #fadeOverlay {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: #d1d5db;
            opacity: 0;
            pointer-events: none;
            transition: opacity 0.1s linear;
            border-radius: 8px;
        }
        .knobs-container {
            display: flex;
            justify-content: space-between;
             /* Responsive Padding */
            padding-left: 0.75rem; /* px-3 */
            padding-right: 0.75rem; /* px-3 */
            padding-top: 0.75rem; /* py-3 */
            margin-top: 0.5rem; /* mt-2 */
        }
         @media (min-width: 640px) { /* sm breakpoint */
             .knobs-container {
                 padding-left: 1.25rem; /* sm:px-5 */
                 padding-right: 1.25rem; /* sm:px-5 */
                 padding-top: 1rem; /* sm:pt-4 */
                 margin-top: 0.75rem; /* sm:mt-3 */
             }
         }

        .knob {
             /* Responsive Knob Size */
            width: 3.5rem; /* w-14 (56px) */
            height: 3.5rem; /* h-14 (56px) */
            border: 3px solid #9ca3af;
            background-color: #ffffff;
            border-radius: 50%;
            position: relative;
            display: flex;
            justify-content: center;
            align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 0 5px rgba(0,0,0,0.1);
            cursor: default;
        }
         @media (min-width: 640px) { /* sm breakpoint */
             .knob {
                 width: 4rem; /* sm:w-16 (64px) */
                 height: 4rem; /* sm:h-16 (64px) */
             }
         }

        .knob-marker {
             /* Adjust marker slightly for smaller base knob size */
            width: 6px;
            height: 40%;
            background-color: #ef4444; /* red-500 */
            position: absolute;
            top: 10%;
            left: calc(50% - 3px); /* Centered */
            transform-origin: bottom center;
            border-radius: 3px;
        }
    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>

    <div id="etch-a-sketch-frame">
        <div style="position: relative;">
            <canvas id="drawingCanvas" width="500" height="350"></canvas>
            <div id="fadeOverlay"></div>
        </div>
        <div class="knobs-container">
            <div class="relative">
                <div id="knobH" class="knob">
                    <div id="markerH" class="knob-marker"></div>
                </div>
            </div>
            <div class="relative">
                <div id="knobV" class="knob">
                    <div id="markerV" class="knob-marker"></div>
                </div>
            </div>
        </div>
    </div>

    <script>
        // Get elements
        const frame = document.getElementById('etch-a-sketch-frame');
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const fadeOverlay = document.getElementById('fadeOverlay');
        const markerH = document.getElementById('markerH');
        const markerV = document.getElementById('markerV');

        // --- State Variables ---
        let isDrawing = false;
        let lastX = 0;
        let lastY = 0;
        let totalAngleH = 0;
        let totalAngleV = 0;
        let isShaking = false;
        let shakeStartX = 0;
        let lastShakeX = 0;
        let lastShakeY = 0;
        let shakeDistance = 0;
        let shakeDirectionChanges = 0;
        let currentFade = 0;
        let lastDeltaXSign = 0;

        // --- Configuration ---
        const pixelsPerDegree = 1;
        ctx.strokeStyle = '#1f2937';
        ctx.lineWidth = 2.5; // Line width remains constant relative to buffer
        ctx.lineJoin = 'round';
        ctx.lineCap = 'round';
        const FADE_INCREMENT = 5;
        const MAX_FADE = 100;
        const SHAKE_THRESHOLD_DISTANCE = 150;
        const SHAKE_THRESHOLD_CHANGES = 4;
        const SHAKE_AMPLITUDE = 3;
        const ROTATION_FACTOR = 0.2;
        const MAX_ROTATION_ANGLE = 2;

        // --- Event Listeners ---
        canvas.addEventListener('mousedown', startDrawing);
        canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('mousemove', draw);
        canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('mouseup', stopDrawing);
        canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('touchend', stopDrawing);
        canvas.addEventListener('touchcancel', stopDrawing);
        frame.addEventListener('mousedown', startShaking);
        frame.addEventListener('touchstart', startShaking);

        // --- Drawing Functions ---
        function startDrawing(e) {
            if (isShaking) return;
            e.preventDefault();
            isDrawing = true;
            // getEventPosition correctly handles scaling via getBoundingClientRect
            const pos = getEventPosition(e, canvas);
            if (!pos) return;
            [lastX, lastY] = [pos.x, pos.y];
            ctx.beginPath();
            ctx.moveTo(lastX, lastY);
        }

        function draw(e) {
            if (!isDrawing || isShaking) return;
            e.preventDefault();
            const pos = getEventPosition(e, canvas);
             if (!pos) return;
            const currentX = pos.x;
            const currentY = pos.y;

            // Drawing coordinates are relative to the 500x350 buffer
            ctx.lineTo(currentX, currentY);
            ctx.stroke();

            const deltaX = currentX - lastX;
            const deltaY = currentY - lastY;
            const deltaAngleH = deltaX / pixelsPerDegree;
            const deltaAngleV = deltaY / pixelsPerDegree;
            totalAngleH += deltaAngleH;
            totalAngleV += deltaAngleV;
            updateKnobs();
            [lastX, lastY] = [currentX, currentY];
        }

        function stopDrawing() {
            isDrawing = false;
        }

        // --- Shaking / Erasing Functions ---
        function startShaking(e) {
            if (isDrawing || e.target.closest('.knob')) return;
            e.preventDefault();
            isShaking = true;
            frame.classList.add('grabbing');
            const pos = getEventPosition(e, window);
            if (!pos) return;
            shakeStartX = pos.x;
            lastShakeX = pos.x;
            lastShakeY = pos.y;
            shakeDistance = 0;
            shakeDirectionChanges = 0;
            lastDeltaXSign = 0;
            window.addEventListener('mousemove', shaking);
            window.addEventListener('touchmove', shaking, { passive: false });
            window.addEventListener('mouseup', stopShaking);
            window.addEventListener('touchend', stopShaking);
        }

        function shaking(e) {
            if (!isShaking) return;
            e.preventDefault();
            const pos = getEventPosition(e, window);
            if (!pos) return;
            const currentX = pos.x;
            const currentY = pos.y;
            const deltaX = currentX - lastShakeX;
            const deltaY = currentY - lastShakeY;
            const currentDeltaXSign = Math.sign(deltaX);
            shakeDistance += Math.abs(deltaX);
            let offsetX = 0;
            if (Math.abs(deltaX) > 0.5) offsetX = Math.sign(deltaX) * SHAKE_AMPLITUDE;
            let rotateAngle = deltaY * ROTATION_FACTOR;
            rotateAngle = Math.max(-MAX_ROTATION_ANGLE, Math.min(MAX_ROTATION_ANGLE, rotateAngle));
            frame.style.transform = `translateX(${offsetX}px) rotate(${rotateAngle}deg)`;
            if (currentDeltaXSign !== 0 && lastDeltaXSign !== 0 && currentDeltaXSign !== lastDeltaXSign && Math.abs(deltaX) > 2) {
                shakeDirectionChanges++;
                currentFade = Math.min(MAX_FADE, currentFade + FADE_INCREMENT);
                updateFade();
            }
            if (currentDeltaXSign !== 0) lastDeltaXSign = currentDeltaXSign;
            lastShakeX = currentX;
            lastShakeY = currentY;
        }

        function stopShaking() {
            if (!isShaking) return;
            frame.style.transform = '';
            if (shakeDistance >= SHAKE_THRESHOLD_DISTANCE && shakeDirectionChanges >= SHAKE_THRESHOLD_CHANGES) {
                clearCanvas();
            } else {
                let interval = setInterval(() => {
                    currentFade = Math.max(0, currentFade - FADE_INCREMENT * 2);
                    updateFade();
                    if (currentFade === 0) clearInterval(interval);
                }, 50);
            }
            isShaking = false;
            frame.classList.remove('grabbing');
            window.removeEventListener('mousemove', shaking);
            window.removeEventListener('touchmove', shaking);
            window.removeEventListener('mouseup', stopShaking);
            window.removeEventListener('touchend', stopShaking);
        }

        // --- Utility Functions ---
        function updateKnobs() {
            markerH.style.transform = `rotate(${totalAngleH}deg)`;
            markerV.style.transform = `rotate(${totalAngleV}deg)`;
        }

        function updateFade() {
            fadeOverlay.style.opacity = currentFade / MAX_FADE;
        }

        function clearCanvas() {
            ctx.clearRect(0, 0, canvas.width, canvas.height);
            totalAngleH = 0;
            totalAngleV = 0;
            currentFade = 0;
            updateKnobs();
            updateFade();
            isDrawing = false;
            ctx.beginPath();
        }

        // Helper to get coordinates relative to the canvas buffer (500x350)
        // even when the canvas element is scaled by CSS
        function getEventPosition(e, element) {
            let clientX, clientY;
            const touch = e.touches?.[0] || e.changedTouches?.[0];

            if (touch) { // Touch event
                clientX = touch.clientX;
                clientY = touch.clientY;
            } else if (e.clientX !== undefined && e.clientY !== undefined) { // Mouse event
                clientX = e.clientX;
                clientY = e.clientY;
            } else {
                return null; // Could not get position
            }

            // If target is window, return client coordinates directly (for shaking)
            if (element === window) {
                return { x: clientX, y: clientY };
            }

            // If target is canvas, calculate position relative to the element
            // and scale it to match the fixed buffer size (500x350)
            const rect = element.getBoundingClientRect();
            const scaleX = element.width / rect.width;    // relationship bitmap vs. element for X
            const scaleY = element.height / rect.height;  // relationship bitmap vs. element for Y

            const canvasX = (clientX - rect.left) * scaleX; // scale mouse coordinates after they have
            const canvasY = (clientY - rect.top) * scaleY;  // been adjusted to be relative to element

             // Clamp coordinates within canvas buffer bounds
            const finalX = Math.max(0, Math.min(element.width, canvasX));
            const finalY = Math.max(0, Math.min(element.height, canvasY));

            return { x: finalX, y: finalY };
        }


        // Initial setup
        updateKnobs();
        updateFade();
        ctx.beginPath();

    </script>

</body>
</html>
