<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Sketch-A-Etch</title> <script src="https://cdn.tailwindcss.com"></script>
    <style>
        /* Custom styles (mostly unchanged) */
        body {
            font-family: 'Inter', sans-serif;
            overscroll-behavior: none;
            user-select: none;
            -webkit-user-select: none;
            -moz-user-select: none;
            -ms-user-select: none;
            display: flex;
            flex-direction: column; /* Stack frame and controls */
            justify-content: center;
            align-items: center;
            min-height: 100vh;
            background-color: #e5e7eb; /* gray-200 - Default */
            overflow: hidden;
            padding: 1rem;
            transition: background-color 0.5s ease;
            position: relative;
        }
        body.disco-mode { background-color: #111827; }

        #etch-a-sketch-frame {
            background-color: #dc2626;
            border-radius: 20px;
            padding: 1rem;
            box-shadow: 0 10px 20px rgba(0, 0, 0, 0.2), inset 0 0 10px rgba(0,0,0,0.3);
            cursor: grab;
            position: relative;
            width: 100%;
            max-width: 32rem;
            border: 2px solid #b91c1c;
            transition: transform 0.1s ease-out, background-color 0.5s ease, border-color 0.5s ease, box-shadow 0.5s ease;
            margin-bottom: 1rem; /* Space below frame */
        }
        @media (min-width: 640px) { #etch-a-sketch-frame { padding: 1.5rem; } }
        body.disco-mode #etch-a-sketch-frame {
            background-color: #1f2937;
            border: 3px solid #a855f7;
            box-shadow: 0 0 15px 5px rgba(168, 85, 247, 0.5), inset 0 0 10px rgba(0,0,0,0.5);
        }
        #etch-a-sketch-frame.grabbing { cursor: grabbing; transition: none; }

        #drawingCanvas {
            touch-action: none;
            cursor: crosshair;
            border-radius: 8px;
            background-color: #d1d5db;
            border: 4px solid #9ca3af;
            box-shadow: inset 0 0 10px rgba(0,0,0,0.2);
            display: block;
            position: relative;
            overflow: hidden;
            width: 100%;
            aspect-ratio: 500 / 350;
            height: auto;
        }
         body.disco-mode #drawingCanvas { border-color: #374151; background-color: #4b5563; }

        #fadeOverlay {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background-color: #d1d5db; opacity: 0; pointer-events: none;
            transition: opacity 0.1s linear, background-color 0.5s ease; border-radius: 8px;
        }
         body.disco-mode #fadeOverlay { background-color: #4b5563; }

        .knobs-container {
            display: flex; justify-content: space-between;
            padding-left: 0.75rem; padding-right: 0.75rem; padding-top: 0.75rem;
            margin-top: 0.5rem;
        }
         @media (min-width: 640px) { .knobs-container { padding-left: 1.25rem; padding-right: 1.25rem; padding-top: 1rem; margin-top: 0.75rem; } }

        .knob {
            width: 3.5rem; height: 3.5rem; border: 3px solid #9ca3af;
            background-color: #ffffff; border-radius: 50%; position: relative;
            display: flex; justify-content: center; align-items: center;
            box-shadow: 0 2px 4px rgba(0, 0, 0, 0.2), inset 0 0 5px rgba(0,0,0,0.1);
            cursor: default; transition: border-color 0.5s ease, background-color 0.5s ease;
        }
         @media (min-width: 640px) { .knob { width: 4rem; height: 4rem; } }
         body.disco-mode .knob { background-color: #374151; border-color: #a855f7; }

        .knob-marker {
            width: 6px; height: 40%; background-color: #ef4444; position: absolute;
            top: 10%; left: calc(50% - 3px); transform-origin: bottom center;
            border-radius: 3px; transition: background-color 0.5s ease;
        }
         body.disco-mode .knob-marker { background-color: #ec4899; }

        /* --- Controls Container --- */
        .controls-container {
            display: flex;
            flex-direction: column; /* Stack controls vertically on small screens */
            align-items: center;
            gap: 0.75rem; /* space-y-3 */
            margin-top: 0.5rem; /* Add some space above controls */
        }
         @media (min-width: 640px) { /* sm breakpoint */
            .controls-container {
                 flex-direction: row; /* Side-by-side on larger screens */
                 gap: 1.5rem; /* space-x-6 */
            }
         }


        /* --- Toggle Switch Styles --- */
        .toggle-label {
            display: flex; align-items: center; cursor: pointer;
            color: #374151; transition: color 0.5s ease; font-size: 0.875rem; /* text-sm */
        }
        body.disco-mode .toggle-label { color: #d1d5db; }
        .toggle-switch {
            position: relative; display: inline-block; width: 50px; height: 28px; margin-left: 10px;
        }
        .toggle-switch input { opacity: 0; width: 0; height: 0; }
        .slider {
            position: absolute; cursor: pointer; top: 0; left: 0; right: 0; bottom: 0;
            background-color: #ccc; transition: .4s; border-radius: 28px;
        }
        .slider:before {
            position: absolute; content: ""; height: 20px; width: 20px; left: 4px; bottom: 4px;
            background-color: white; transition: .4s; border-radius: 50%;
        }
        input:checked + .slider { background-color: #a855f7; }
        input:checked + .slider:before { transform: translateX(22px); }

        /* --- Sparkle Styles --- */
        #sparkle-container { position: absolute; top: 0; left: 0; width: 100%; height: 100%; overflow: hidden; pointer-events: none; z-index: -1; }
        .sparkle { position: absolute; width: 4px; height: 4px; background-color: white; border-radius: 50%; opacity: 0; animation: sparkle-anim 1.5s infinite ease-in-out; }
        @keyframes sparkle-anim { 0%, 100% { opacity: 0; transform: scale(0.5) rotate(0deg); } 50% { opacity: 0.8; transform: scale(1) rotate(180deg); } }

        /* --- Shake Permission Button Style --- */
        #shakePermissionButton {
            font-size: 0.75rem; /* text-xs */
            padding: 0.25rem 0.5rem; /* py-1 px-2 */
            border: 1px solid #9ca3af; /* gray-400 */
            border-radius: 0.375rem; /* rounded */
            color: #4b5563; /* gray-600 */
            background-color: #f3f4f6; /* gray-100 */
            cursor: pointer;
            transition: background-color 0.2s ease, color 0.2s ease;
        }
        #shakePermissionButton:hover { background-color: #e5e7eb; /* gray-200 */ }
        #shakePermissionButton:disabled { cursor: not-allowed; opacity: 0.6; }
        body.disco-mode #shakePermissionButton {
             border-color: #6b7280; /* gray-500 */
             color: #d1d5db; /* gray-300 */
             background-color: #374151; /* gray-700 */
        }
         body.disco-mode #shakePermissionButton:hover { background-color: #4b5563; /* gray-600 */ }


    </style>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;700&display=swap" rel="stylesheet">
</head>
<body>
    <div id="sparkle-container"></div>

    <div id="etch-a-sketch-frame">
        <div style="position: relative;">
            <canvas id="drawingCanvas" width="500" height="350"></canvas>
            <div id="fadeOverlay"></div>
        </div>
        <div class="knobs-container">
            <div class="relative">
                <div id="knobH" class="knob">
                    <div id="markerH" class="knob-marker"></div>
                </div>
            </div>
            <div class="relative">
                <div id="knobV" class="knob">
                    <div id="markerV" class="knob-marker"></div>
                </div>
            </div>
        </div>
    </div>

    <div class="controls-container">
        <label class="toggle-label" for="discoToggle">
            Disco Mode
            <div class="toggle-switch">
                <input type="checkbox" id="discoToggle">
                <span class="slider"></span>
            </div>
        </label>

        <button id="shakePermissionButton">Enable Shake-to-Erase</button>
    </div>


    <script>
        // Get elements
        const frame = document.getElementById('etch-a-sketch-frame');
        const canvas = document.getElementById('drawingCanvas');
        const ctx = canvas.getContext('2d');
        const fadeOverlay = document.getElementById('fadeOverlay');
        const markerH = document.getElementById('markerH');
        const markerV = document.getElementById('markerV');
        const discoToggle = document.getElementById('discoToggle');
        const body = document.body;
        const sparkleContainer = document.getElementById('sparkle-container');
        const shakePermissionButton = document.getElementById('shakePermissionButton'); // Get button

        // --- State Variables ---
        let isDrawing = false; let lastX = 0; let lastY = 0;
        let totalAngleH = 0; let totalAngleV = 0;
        let isShaking = false; let shakeStartX = 0; let lastShakeX = 0; let lastShakeY = 0;
        let shakeDistance = 0; let shakeDirectionChanges = 0; let currentFade = 0; let lastDeltaXSign = 0;
        let isDiscoMode = false; let discoHue = 0; let sparkleInterval = null;
        // Shake detection state
        let motionListenerEnabled = false;
        let lastAccel = { x: null, y: null, z: null };
        let shakeCount = 0;
        let lastShakeTime = 0;
        let eraseCooldownUntil = 0; // Timestamp until which erase is on cooldown

        // --- Configuration ---
        const pixelsPerDegree = 1; const defaultStrokeStyle = '#1f2937';
        ctx.lineWidth = 2.5; ctx.lineJoin = 'round'; ctx.lineCap = 'round';
        const FADE_INCREMENT = 5; const MAX_FADE = 100;
        const SHAKE_THRESHOLD_DISTANCE = 150; const SHAKE_THRESHOLD_CHANGES = 4;
        const SHAKE_AMPLITUDE = 3; const ROTATION_FACTOR = 0.2; const MAX_ROTATION_ANGLE = 2;
        const NUM_SPARKLES = 50;
        // Shake detection config
        const SHAKE_SENSITIVITY = 15; // Acceleration threshold (tune this value)
        const SHAKE_COUNT_THRESHOLD = 2; // How many shakes needed
        const SHAKE_TIME_WINDOW = 500; // Milliseconds window for shakes
        const ERASE_COOLDOWN_MS = 2000; // Cooldown after shake-erase (2 seconds)


        // --- Event Listeners ---
        canvas.addEventListener('mousedown', startDrawing); canvas.addEventListener('touchstart', startDrawing);
        canvas.addEventListener('mousemove', draw); canvas.addEventListener('touchmove', draw);
        canvas.addEventListener('mouseup', stopDrawing); canvas.addEventListener('mouseout', stopDrawing);
        canvas.addEventListener('touchend', stopDrawing); canvas.addEventListener('touchcancel', stopDrawing);
        frame.addEventListener('mousedown', startShaking); frame.addEventListener('touchstart', startShaking);
        discoToggle.addEventListener('change', toggleDiscoMode);
        shakePermissionButton.addEventListener('click', requestMotionPermission); // Listener for permission button

        // --- Device Motion Permission & Handling ---
        function requestMotionPermission() {
            // Check if permission API exists (iOS 13+)
            if (typeof DeviceMotionEvent !== 'undefined' && typeof DeviceMotionEvent.requestPermission === 'function') {
                DeviceMotionEvent.requestPermission()
                    .then(permissionState => {
                        if (permissionState === 'granted') {
                            enableMotionDetection();
                            shakePermissionButton.textContent = 'Shake Enabled';
                            shakePermissionButton.disabled = true;
                        } else {
                            shakePermissionButton.textContent = 'Permission Denied';
                            shakePermissionButton.disabled = true;
                            // Optionally inform user permission is needed
                        }
                    })
                    .catch(error => {
                        console.error("Error requesting device motion permission:", error);
                        shakePermissionButton.textContent = 'Error Requesting';
                        // Handle error (e.g., user dismissed prompt)
                    });
            } else {
                // Handle non-iOS 13+ devices or environments where API isn't available
                // Try enabling directly (might work on Android, might not)
                enableMotionDetection();
                if (motionListenerEnabled) { // Check if listener was actually added
                     shakePermissionButton.textContent = 'Shake Possibly Enabled';
                     shakePermissionButton.disabled = true;
                } else {
                     shakePermissionButton.textContent = 'Shake Not Supported';
                     shakePermissionButton.disabled = true;
                }
            }
        }

        function enableMotionDetection() {
             if (!motionListenerEnabled) {
                 window.addEventListener('devicemotion', handleDeviceMotion);
                 motionListenerEnabled = true;
                 console.log("Device motion listener added.");
             }
        }

        function handleDeviceMotion(event) {
            const currentTime = Date.now();
            // Don't detect shake if already shaking frame or on cooldown
            if (isShaking || currentTime < eraseCooldownUntil) {
                return;
            }

            // Use accelerationIncludingGravity for broader compatibility
            const accel = event.accelerationIncludingGravity;
            if (!accel || accel.x === null || accel.y === null || accel.z === null) {
                // No valid acceleration data
                return;
            }

            if (lastAccel.x !== null) { // Check if we have previous data
                const deltaX = Math.abs(accel.x - lastAccel.x);
                const deltaY = Math.abs(accel.y - lastAccel.y);
                const deltaZ = Math.abs(accel.z - lastAccel.z);

                // Simple shake detection: sum of absolute changes
                const movement = deltaX + deltaY + deltaZ;

                if (movement > SHAKE_SENSITIVITY) {
                    // Shake detected
                    const timeSinceLastShake = currentTime - lastShakeTime;

                    if (timeSinceLastShake < SHAKE_TIME_WINDOW) {
                        shakeCount++; // Increment if shake is within the time window
                    } else {
                        shakeCount = 1; // Reset count if too much time has passed
                    }

                    lastShakeTime = currentTime; // Update last shake time

                    console.log(`Shake detected! Movement: ${movement.toFixed(2)}, Count: ${shakeCount}`); // Debug log

                    if (shakeCount >= SHAKE_COUNT_THRESHOLD) {
                        console.log("Shake threshold reached - ERASING!");
                        clearCanvas(); // Erase the canvas
                        shakeCount = 0; // Reset shake count
                        eraseCooldownUntil = currentTime + ERASE_COOLDOWN_MS; // Set cooldown
                        // Optional: Vibrate device
                        if (navigator.vibrate) {
                             navigator.vibrate(100); // Vibrate for 100ms
                        }
                    }
                }
            }

            // Store current acceleration for next event
            lastAccel.x = accel.x;
            lastAccel.y = accel.y;
            lastAccel.z = accel.z;
        }


        // --- Disco Mode Toggle Function --- (Unchanged)
        function toggleDiscoMode() {
            isDiscoMode = discoToggle.checked;
            body.classList.toggle('disco-mode', isDiscoMode);
            if (!isDrawing) { ctx.strokeStyle = isDiscoMode ? `hsl(${discoHue}, 100%, 55%)` : defaultStrokeStyle; }
            if (isDiscoMode) { startSparkles(); } else { stopSparkles(); }
        }

        // --- Drawing Functions --- (Unchanged from previous version)
        function startDrawing(e) { /* ... */ }
        function draw(e) { /* ... */ }
        function stopDrawing() { /* ... */ }
        // Note: The specific implementation of startDrawing, draw, stopDrawing are kept from the previous version where direct canvas drawing was used.

        // --- Shaking / Erasing Functions --- (Drag-to-erase unchanged)
        function startShaking(e) { /* ... */ }
        function shaking(e) { /* ... */ }
        function stopShaking() { /* ... */ }
        // Note: The specific implementation of startShaking, shaking, stopShaking are kept from the previous version.

        // --- Utility Functions --- (Unchanged)
        function updateKnobs() { /* ... */ }
        function updateFade() { /* ... */ }
        function clearCanvas() { // Added cooldown reset check
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             totalAngleH = 0; totalAngleV = 0; currentFade = 0;
             updateKnobs(); updateFade(); isDrawing = false;
             ctx.strokeStyle = isDiscoMode ? `hsl(${discoHue}, 100%, 55%)` : defaultStrokeStyle;
             ctx.shadowBlur = 0; ctx.shadowColor = 'transparent';
             ctx.beginPath();
             // Reset shake detection state variables after clear
             shakeCount = 0;
             lastAccel = { x: null, y: null, z: null };
             // Keep eraseCooldownUntil as is, it prevents immediate re-triggering
             console.log("Canvas Cleared.");
        }
        function getEventPosition(e, element) { /* ... */ }
        // Note: The specific implementation of these utilities are kept from the previous version.

        // --- Sparkle Effect Functions --- (Unchanged)
        function createSparkle() { /* ... */ }
        function startSparkles() { /* ... */ }
        function stopSparkles() { /* ... */ }
        // Note: The specific implementation of these sparkle functions are kept from the previous version.


        // Initial setup (Unchanged)
        updateKnobs(); updateFade(); ctx.strokeStyle = defaultStrokeStyle; ctx.beginPath();

    </script>

</body>
</html>
